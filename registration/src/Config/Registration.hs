{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

-- | Handles configuration, which involves parsing command line
-- arguments and reading key files.

module Config.Registration
  ( Config(Config)
  , ConfigError
  , opts
  , mkConfig
  , Opts(Opts)
  , parseOpts
  , MetadataOutFormat(..)
  ) where

import           Cardano.Catalyst.Registration (DelegationWeight, Delegations (..))
import           Control.Exception.Safe (try)
import           Control.Lens ((#))
import           Control.Lens.TH
import           Control.Monad.Except (ExceptT, MonadError, throwError)
import           Control.Monad.IO.Class (MonadIO, liftIO)
import qualified Data.Attoparsec.ByteString.Char8 as Atto
import qualified Data.ByteString.Char8 as BC
import           Data.Char (isSpace)
import           Data.Foldable (asum)
import           Data.List.NonEmpty (NonEmpty)
import qualified Data.List.NonEmpty as NE
import           Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import           Data.Traversable (forM)
import           Data.Word (Word32)

import           Options.Applicative

import           Cardano.Api (Bech32DecodeError, StakeAddress)
import qualified Cardano.Api as Api
import           Cardano.CLI.Shelley.Key (InputDecodeError)
import           Cardano.CLI.Types (SigningKeyFile (..))
import           Cardano.Catalyst.Crypto (StakeSigningKey, readStakeSigningKeyFile)
import           Config.Common (versionOption)

import           Cardano.API.Extended (AsBech32DecodeError (_Bech32DecodeError),
                   AsFileError (_FileIOError, __FileError), AsInputDecodeError (_InputDecodeError),
                   AsType (AsVotingKeyPublic), VotingKeyPublic, deserialiseFromBech32',
                   parseStakeAddress, readerFromAttoParser)

data Config = Config
    { cfgRewardsAddress  :: Api.Address Api.ShelleyAddr
    , cfgStakeSigningKey :: StakeSigningKey
    , cfgDelegations     :: Delegations VotingKeyPublic
    , cfgSlotNo          :: Api.SlotNo
    , cfgOutFormat       :: MetadataOutFormat
    }
    deriving (Show)

data MetadataOutFormat = MetadataOutFormatJSON
                       | MetadataOutFormatCBOR
    deriving (Eq, Show)

data FileErrors = FileErrorInputDecode InputDecodeError
    deriving (Show)

makePrisms ''FileErrors

instance AsInputDecodeError FileErrors where
  _InputDecodeError = _FileErrorInputDecode

data ConfigError = ConfigFailedToReadFile (Api.FileError FileErrors)
    | ConfigFailedToDecodeBech32 Bech32DecodeError
    deriving (Show)

makePrisms ''ConfigError

instance AsFileError ConfigError FileErrors where
  __FileError = _ConfigFailedToReadFile

instance AsBech32DecodeError ConfigError where
  _Bech32DecodeError = _ConfigFailedToDecodeBech32

mkConfig
  :: Opts
  -> ExceptT ConfigError IO Config
mkConfig (Opts rewardsAddr delegations vskf slotNo outFormat) = do
  stkSign <- readStakeSigningKeyFile (SigningKeyFile vskf)

  delegations' <- case delegations of
    LegacyDelegationCLI vpkf -> do
      votepk <- readVotePublicKey vpkf
      pure $ Delegations $ (votepk, 1) NE.:| []
    DelegationsCLI keyWeights ->
      fmap Delegations . forM keyWeights $ \(vpkf, weight) -> do
        votepk <- readVotePublicKey vpkf
        pure $ (votepk, weight)

  pure $ Config rewardsAddr stkSign delegations' slotNo outFormat

data Opts = Opts
    { optRewardsAddress      :: StakeAddress
    , optVotePublicKeyFile   :: DelegationsCLI
    , optStakeSigningKeyFile :: FilePath
    , optSlotNo              :: Api.SlotNo
    , optOutFormat           :: MetadataOutFormat
    }
    deriving (Show)

parseOpts :: Parser Opts
parseOpts = Opts
  <$> option (readerFromAttoParser parseStakeAddress) (long "rewards-address" <> metavar "STRING" <> help "address associated with rewards (Must be a stake address for MIR Certificate)")
  <*> pDelegationsCLI
  <*> strOption (long "stake-signing-key-file" <> metavar "FILE" <> help "stake authorizing vote key")
  <*> pSlotNo
  <*> pOutFormat

data DelegationsCLI
  = LegacyDelegationCLI FilePath
  | DelegationsCLI (NonEmpty (FilePath, DelegationWeight))
  deriving Show

pDelegationLegacy :: Parser DelegationsCLI
pDelegationLegacy =
  LegacyDelegationCLI
  <$> strOption (
    long "vote-public-key-file"
    <> metavar "FILE"
    <> help "vote key generated by jcli (corresponding private key must be ed25519extended)"
    )

pDelegationCIP36 :: Parser (FilePath, Word32)
pDelegationCIP36 =
  option
    (readerFromAttoParser pSingleDelegationCIP36)
    (  long "delegate"
    <> metavar "FILE,WEIGHT"
    <> help "ED25519Extended public voting key and delegation weight"
    )

pSingleDelegationCIP36 :: Atto.Parser (FilePath, Word32)
pSingleDelegationCIP36 = do
  _ <- pSpace
  vpkf <- pVotePublicKeyFile
  _ <- Atto.string ","
  weight <- pKeyWeight
  pure $ (vpkf, weight)
  where
    sep = ','
    isSep = (== sep)
    pSpace = Atto.skipWhile isSpace
    pVotePublicKeyFile = BC.unpack <$> Atto.takeWhile1 (not . isSep)
    pKeyWeight = Atto.decimal

pDelegationsCLI :: Parser DelegationsCLI
pDelegationsCLI =
  pDelegationLegacy
  <|> ((DelegationsCLI . NE.fromList) <$> (some pDelegationCIP36))


opts :: ParserInfo Opts
opts =
  info
    ( parseOpts <**> versionOption "0.3.0.0" <**> helper )
    ( fullDesc
    <> progDesc "Create vote registration metadata"
    <> header "voter-registration - a tool to create vote registration metadata suitable for attaching to a transaction"
    )

stripTrailingNewlines :: Text -> Text
stripTrailingNewlines = T.intercalate "\n" . filter (not . T.null) . T.lines

readVotePublicKey
  :: ( MonadIO m
     , MonadError e m
     , AsFileError e d
     , AsBech32DecodeError e
     )
  => FilePath
  -> m VotingKeyPublic
readVotePublicKey path = do
  result <- liftIO . try $ TIO.readFile path
  raw    <- either (\e -> throwError . (_FileIOError #) $ (path, e)) pure result
  let publicKeyBech32 = stripTrailingNewlines raw
  either (throwError . (_Bech32DecodeError #)) pure $ deserialiseFromBech32' AsVotingKeyPublic publicKeyBech32

pOutFormat :: Parser MetadataOutFormat
pOutFormat = asum
  [ flag' MetadataOutFormatJSON
      ( long "json"
      <> help "Output metadata in JSON format (using the 'NoSchema' TxMetadata JSON format - the default for cardano-cli)"
      )
  , flag' MetadataOutFormatCBOR
      ( long "cbor"
      <> help "Output metadata in binary CBOR format"
      )
  ]

pSlotNo :: Parser Api.SlotNo
pSlotNo = Api.SlotNo
    <$> option auto
          ( long "slot-no"
          <> metavar "WORD64"
          <> help "Slot number to encode in vote registration. Used to prevent replay attacks. Use the chain tip if you're unsure."
          )
